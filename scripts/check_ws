#!/usr/bin/env python
"""
plot the shape from workspace, written in py2
"""
from __future__ import print_function
from __future__ import division

from checkws.ws_reader import WSReader
import os
import argparse
from checkws.root_utils import redefine_range
from checkws.root_utils import print_hist
from checkws.root_utils import sumw2
from checkws.ploter import Ploter
from checkws import adder

import ROOT
ROOT.gROOT.SetBatch()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="check yields and shape for WS")
    add_arg = parser.add_argument

    # input and output info
    add_arg('file_name', help='Input workspace file')
    add_arg('-o', "--out_dir", help="name of output directory", default="out")
    add_arg('--postfix', help='postfix used in naming histograms', default='nominal')
    add_arg('-v', '--verbose', help='print info for debuging', action='store_true')
    add_arg('--recreate', help='create histograms anyway even they already exist', action='store_true')

    # workspace information
    add_arg("-w", "--wsname", default='combined')
    add_arg("-m", '--mcname', default='ModelConfig')
    add_arg("-d", '--dataname', default='obsData', help="name of observed data")
    add_arg("--poi_name", help="name of POI", default="SigXsecOverSM")

    # change workspace contents
    add_arg("--fixVar", help="set variables as constant:  mu=1,lumi=1", default=None)
    add_arg("--floatVar", help="set variables float:  mu_ggF,mu_VBF", default=None)
    add_arg("--signalScale", help="scale factor applied to data", default=5., type=float)
    add_arg("--add-bkg-sys", help="add systematic uncertainties on background", action='store_true')

    # fitting related
    add_arg("--afterFit", help="make plots and yields after fit", action="store_true")
    add_arg("--save-fitted-to", help='save fitted results to a ROOT file', default='fitted.root')
    add_arg('--save-snapshot-to', help='snapshot name of fitted results', default='nllFit')
    add_arg("--conditionalFit", help="in conditional fit, POI is set to constant", action="store_true")
    add_arg("--matrix", help="plot covariance matrix", action='store_true')

    ## for plotting
    add_arg("--lumi", help="which luminosity used",  default=139, type=float)
    add_arg("--plot-type", help='Internal or preliminary',
            default='Internal', choices=['Internal', 'Preliminary', ' '])
    add_arg("--noPlot", help="don't make plots", action="store_true")
    add_arg("--nBins", help="setup binning of the observable", default=60, type=int)
    add_arg("--xMax", help="max value of the observable", default=2000, type=float)
    add_arg("--xMin", help="min value of the observable", default=200, type=float)
    add_arg("--logY", help="if log scale for y-axis", action="store_true")
    add_arg("--signal-mc", help='signal MC names', default='VBF, ggF, VBFH, ggH')
    #add_arg("--signal-mc", help='signal MC names', default='ggF, ggH')

    try:
        args = parser.parse_args()
    except:
        parser.print_help()
        exit(2)

    file_name = args.file_name
    out_dir = args.out_dir
    postfix = args.postfix
    verbose = args.verbose
    add_bkg_sys = args.add_bkg_sys
    force_update = args.recreate

    if not os.path.exists(out_dir):
        os.makedirs(out_dir)

    ws_reader = WSReader(
        file_name, out_dir,
        ws_name=args.wsname,
        mc_name=args.mcname,
        data_name=args.dataname,
        poi_name=args.poi_name
    )
    if not ws_reader.data or not ws_reader.poi:
        exit(1)

    print("Categories:", ws_reader.category_names)
    print("MC samples:", ws_reader.mc_samples)
    signal_mcs = [x.strip() for x in args.signal_mc.split(',')]
    print("Signal samples:", signal_mcs)

    ws_reader.poi.setVal(args.signalScale)
    print ("poi: ")
    ws_reader.poi.Print()
    ws_reader.init_NPs()

    if args.fixVar:
        ws_reader.fix_var_str(args.fixVar)
    
    if args.floatVar:
        ws_reader.float_var_str(args.floatVar)

    obs_vars = ws_reader.mc.GetObservables()
    print("obs_vars size:", obs_vars.getSize())
    if obs_vars.getSize()>1:
      oitr = ROOT.TIter(obs_vars.createIterator())
      ovar = oitr()
      while ovar:
        ovar.Print()
        #if "Cat" not in ovar.GetName():
        #   obs_bin_width = (ovar.getMax() - ovar.getMin()) / ovar.getBins()
        #   obs_bins = (ovar.getMin(), ovar.getMax(), ovar.getBins(), obs_bin_width)
        #   print("Binning info of observable {}: {}, {} with {} bins, bin-width: {} GeV".format(
        #       ovar.GetName(), *obs_bins))
        ovar = oitr()

    obs_4l = ws_reader.ws.var("m4l")
    if obs_4l : redefine_range(obs_4l, args.nBins, args.xMax, args.xMin)
    obs_var = ws_reader.mc.GetObservables().first()

    # fitting
    snapshot_name = args.save_snapshot_to
    fitted_file_name = args.save_fitted_to
    mu_VBF = ws_reader.ws.var("mu_VBF")
    mu_ggF = ws_reader.ws.var("mu_ggF")
    if not mu_VBF: mu_VBF = ws_reader.ws.var("XS_VBF")
    if not mu_ggF: mu_ggF = ws_reader.ws.var("XS_ggF")
    if mu_VBF: 
        mu_VBF.setMin(0.)
    if mu_ggF: 
        mu_ggF.setMin(0.)

    if args.afterFit:
        if args.conditionalFit:
            ws_reader.fix_var(ws_reader.poi.GetName(), ws_reader.poi.getVal())
        ws_reader.fit(snapshot_name, save_to_file=fitted_file_name, do_matrix=args.matrix)

    # make histograms
    norm_hist_name = ws_reader.loop_categories(postfix=postfix, force_update=force_update)

    # background systematic uncertainties
    # obtained by changing all nuisance parameters +/- their error
    # in the nominal pre-fit case, the errors are zero, now corrected to be one.
    up_postfix, down_postfix = 'up', 'down'
    if not add_bkg_sys:
        print("No systematic uncertainties on Background!")
    else:
        # get error of each NP and change them +/- 1 error
        nuisances = ws_reader.mc.GetNuisanceParameters()
        nuisance_snapshot_name = "nuisance_norminal"
        ws_reader.ws.saveSnapshot(nuisance_snapshot_name, nuisances)
        # nuisances.Print("v")
        itr = ROOT.TIter(nuisances.createIterator())
        var = itr()
        while var:
            name = var.GetName()
            error = var.getError()
            norm_val = var.getVal()
            if abs(error) < 1E-10:
                error = 1.
            if verbose:
                print("{}: {} +/- {}".format(name, norm_val, error))
            var = itr()
	muZZs = ["muZZ_VBF", "muZZ_rest", "muZZ_ggF", "muZZ", "mu_llll_ZZ_VBF", "mu_llll_ZZ_ggF", "mu_llll_ZZ_rest", "mu_llvv_ZZ", "mu_llll_ZZ"]
        # up
        itr = itr.Begin()
        var = itr()
        while var:
            name = var.GetName()
            ## skip ZZ normalization factors
            if "mu" in name and "ZZ" in name:
              var = itr()
              continue 
            error = var.getError()
            norm_val = var.getVal()
            if abs(error) < 1E-10:
                error = 1.
            var.setVal(norm_val+error)
            var = itr()
	for vname in muZZs:
	    var = ws_reader.ws.var(vname)
	    if var:
                error = var.getError()
                norm_val = var.getVal()
                var.setVal(norm_val+error)
        up_hist_name = ws_reader.loop_categories(postfix=up_postfix, force_update=force_update)
        ws_reader.ws.loadSnapshot(nuisance_snapshot_name)
        # down
        itr = itr.Begin()
        var = itr()
        while var:
            name = var.GetName()
            ## skip ZZ normalization factors
            if "mu" in name and "ZZ" in name:
              var = itr()
              continue 
            error = var.getError()
            norm_val = var.getVal()
            if "mu" in name and "ZZ" in name:
	        print(name, error)
            if abs(error) < 1E-10:
                error = 1.
            var.setVal(norm_val-error)
            var = itr()
	for vname in muZZs:
	    var = ws_reader.ws.var(vname)
	    if var:
                error = var.getError()
                norm_val = var.getVal()
                var.setVal(norm_val-error)
        down_hist_name = ws_reader.loop_categories(postfix=down_postfix, force_update=force_update)
        ws_reader.ws.loadSnapshot(nuisance_snapshot_name)

    # Now plotting
    if args.noPlot:
        exit(0)

    f_hist = ROOT.TFile(norm_hist_name)
    if add_bkg_sys:
        f_up = ROOT.TFile(up_hist_name)
        f_down = ROOT.TFile(down_hist_name)

    ps = Ploter(args.plot_type, args.lumi)

    # Correlation matrix
    if args.afterFit:
        if args.matrix:
          ps.plot_correlation(ws_reader.corr, ws_reader.out_dir+"/correlation_matrix", 0.05) 

    for cat_name in ws_reader.category_names:
        raw_hist_list = []
        raw_tag_list = []
        # get the correct obs based on different channels
        if obs_vars.getSize()>1:
            oitr = ROOT.TIter(obs_vars.createIterator())
            ovar = oitr()
            while ovar:
              name = ovar.GetName()
              if "llll" in cat_name and "m4l" in name:
                obs_var=ovar
	        #redefine_range(obs_var, args.nBins, args.xMax, args.xMin)
                break
              if "llvv" in cat_name and "mT" in name:
                obs_var=ovar
                break
              ovar = oitr()

        for mc in ws_reader.mc_samples:
            if mc in signal_mcs:
                continue
            hist_name = '{}-{}-{}__{}'.format(mc, cat_name, postfix, obs_var.GetName())
            hist = f_hist.Get(hist_name)
            if not hist:
              print ("\nWARNING!! hist not found:", hist_name, "\n")
              continue
            hist.SetDirectory(0)
            if add_bkg_sys:
                # access up and down histograms and calculate the variations
                hist_name = '{}-{}-{}__{}'.format(mc, cat_name, up_postfix, obs_var.GetName())
                hist_up = f_up.Get(hist_name)
                hist_name = '{}-{}-{}__{}'.format(mc, cat_name, down_postfix, obs_var.GetName())
                hist_down = f_down.Get(hist_name)
                if hist_up and hist_down:
                  for ibin in range(hist.GetNbinsX()):
                    norm_val = hist.GetBinContent(ibin+1)
                    up_val = hist_up.GetBinContent(ibin+1)
                    down_val = hist_down.GetBinContent(ibin+1)
                    # symmetric error
                    error = abs(up_val - down_val)*0.5
                    hist.SetBinError(ibin, error)
                else:
                  print("   WARNIGN!! up/down hist not found")
                  print("   hist_down:", hist_name)
            else: # add every small error
                for ibin in range(hist.GetNbinsX()):
                    hist.SetBinError(ibin+1, 1E-6)

	    hist = ws_reader.translate_binning(hist, cat_name)
            raw_hist_list.append(hist)
            raw_tag_list.append(mc)

        if len(raw_hist_list)==0: continue

        # sort them by number of yields
        sorted_idx = sorted(range(len(raw_hist_list)), key=lambda x: raw_hist_list[x].Integral(), reverse=True)
        hist_list = [raw_hist_list[idx] for idx in sorted_idx]
        tag_list = [raw_tag_list[idx] for idx in sorted_idx]

        hist_data = f_hist.Get("data-{}-{}".format(cat_name, postfix))
	hist_data = ws_reader.translate_binning(hist_data, cat_name)
        hist_splusb = f_hist.Get("splusb-{}-{}__{}".format(cat_name, postfix, obs_var.GetName()))
	hist_splusb = ws_reader.translate_binning(hist_splusb, cat_name)
        hist_sonlypdf = f_hist.Get("Signal-{}-{}__{}".format(cat_name, postfix, obs_var.GetName()))
	hist_sonlypdf = ws_reader.translate_binning(hist_sonlypdf, cat_name)
        hist_sonly = f_hist.Get("signalOnly-{}-{}".format(cat_name, postfix))
	hist_sonly = ws_reader.translate_binning(hist_sonly, cat_name)
        sumw2(hist_data)

        ps.color(hist_list)
        sum_bkg, hs = ps.stack(hist_list)
        sum_bkg.SetLineColor(1)

        ps.prepare_2pad_canvas("canvas", 600, 600)
        ps.pad2.cd()
 
        new_data_copy = hist_data.Clone("data_copy")
        # in the ratio panel, add a band representing data states uncertainty
        data_band = adder.make_error_band3(sum_bkg, center=1., width=0.)
        # only draw stat error for data/MC ratio
        sum_bkg_copy = sum_bkg.Clone("bkg_copy")
        for ibin in range(sum_bkg_copy.GetNbinsX()): sum_bkg_copy.SetBinError(ibin, 1E-6) 
        ps.add_ratio_panel([new_data_copy, sum_bkg_copy], "Data/MC", 0.50, 2.0)
        data_band.Draw("E2 same")

        ps.pad1.cd()
        ps.get_offset(hist_splusb)
        ps.set_y_range([hist_data, hist_splusb], args.logY)
        hist_data.SetXTitle(obs_var.GetName())
        #hist_data.SetYTitle("Events / {:.1f} GeV".format(obs_bin_width))
        hist_data.SetYTitle("Events")

        if hist_data:
            legend = ps.get_legend(len(hist_list) + 3)
            legend.AddEntry(hist_data, "Data {:.0f}".format(hist_data.Integral()), "LP")
            hist_data.SetMarkerStyle(20)
            hist_data.SetMarkerSize(1)
            hist_data.Draw("EP")
            hs.Draw("HIST same")


            # show error band for the total background curve
            sum_bkg.SetFillStyle(3244)
            sum_bkg.SetFillColor(2)
            sum_bkg.SetLineColor(2)
            sum_bkg.SetMarkerSize(0.01)
            sum_bkg.Draw("EP same")

            hist_data.Draw("AXISsame")
            hist_data.Draw("EPsame")
            if hist_sonlypdf:
                hist_sonlypdf.Draw("HIST same")
        else:
            legend = ps.get_legend(len(hist_list) + 2)
            hist_splusb.Draw("HIST")
            hs.Draw("E2")
            if hist_sonlypdf:
                hist_sonlypdf.Draw("HIST same")

        #legend.AddEntry(hist_sonly, "S({:.1f}) {:.1f}" .format(self.poi.getVal(), hist_sonly.Integral()), "L")
        if hist_sonlypdf:
            legend.AddEntry(hist_sonlypdf, "S({:.1f}) {}" .format(ws_reader.poi.getVal(), print_hist(hist_sonly, add_bkg_sys)), "L")
        # legend.AddEntry(hist_splusb, "S({:.1f})+B {}" .format(ws_reader.poi.getVal(), print_hist(hist_splusb, add_bkg_sys)), "L")
        legend.AddEntry(sum_bkg, "Total Bkg {}".format(print_hist(sum_bkg, add_bkg_sys)), "F")

        for hist, tag in zip(hist_list, tag_list):
            legend.AddEntry(hist, tag+" {}".format(print_hist(hist, add_bkg_sys)), "F")

        legend.Draw("same")
        ps.add_atlas()
        ps.add_lumi()

        ps.can.SaveAs(os.path.join(ws_reader.out_dir, "{}.pdf".format(cat_name)))
        #ps.can.SaveAs(os.path.join(ws_reader.out_dir, "{}.eps".format(cat_name)))   

    f_hist.Close()
    if add_bkg_sys:
        f_up.Close()
        f_down.Close()
