#!/usr/bin/env python
"""
plot the shape from workspace, written in py2
"""
# from __future__ import print_function

from checkws.ws_reader import WSReader
import os
import argparse
from checkws.root_utils import redefine_range
from checkws.root_utils import print_hist
from root_plot_utils.ploter import Ploter

import ROOT
ROOT.gROOT.SetBatch()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="check yields and shape for WS")
    add_arg = parser.add_argument

    # input and output info
    add_arg('file_name', help='Input workspace file')
    add_arg('-o', "--out_dir", help="name of output directory", default="out")
    add_arg('--postfix', help='postfix used in naming histograms', default='nominal')
    add_arg('-v', '--verbose', help='print info for debuging', action='store_true')
    # workspace information
    add_arg("-w", "--wsname", default='combined')
    add_arg("-m", '--mcname', default='ModelConfig')
    add_arg("-d", '--dataname', default='obsData', help="name of observed data")
    add_arg("--poi_name", help="name of POI", default="SigXsecOverSM")

    # change workspace contents
    add_arg("--fixVar", help="set variables as constant:  mu=1,lumi=1", default=None)
    add_arg("--floatVar", help="set variables float:  mu_ggF,mu_VBF", default=None)
    add_arg("--signalScale", help="scale factor applied to data", default=10., type=float)
    add_arg("--add-bkg-sys", help="add systematic uncertainties on background", action='store_true')

    # fitting related
    add_arg("--afterFit", help="make plots and yields after fit", action="store_true")
    add_arg("--save-fitted-to", help='save fitted results to a ROOT file', default='fitted.root')
    add_arg('--save-snapshot-to', help='snapshot name of fitted results', default='nllFit')
    add_arg("--conditionalFit", help="in conditional fit, POI is set to constant", action="store_true")
    add_arg("--matrix", help="plot covariance matrix", action='store_true')

    ## for plotting
    add_arg("--lumi", help="which luminosity used",  default=139, type=float)
    add_arg("--plot-type", help='Internal or preliminary',
            default='Internal', choices=['Internal', 'Preliminary', ' '])
    add_arg("--noPlot", help="don't make plots", action="store_true")
    add_arg("--nBins", help="setup binning of the observable", default=10000, type=int)
    add_arg("--xMax", help="max value of the observable", default=0, type=float)
    add_arg("--xMin", help="min value of the observable", default=100000, type=float)
    add_arg("--logY", help="if log scale for y-axis", action="store_true")
    add_arg("--signal-mc", help='signal MC names', default='VBF, ggF')

    try:
        args = parser.parse_args()
    except:
        parser.print_help()
        exit(2)

    file_name = args.file_name
    out_dir = args.out_dir
    postfix = args.postfix
    verbose = args.verbose
    add_bkg_sys = args.add_bkg_sys
    if not os.path.exists(out_dir):
        os.makedirs(out_dir)

    ws_reader = WSReader(
        file_name, out_dir,
        ws_name=args.wsname,
        mc_name=args.mcname,
        data_name=args.dataname,
        poi_name=args.poi_name
    )
    if not ws_reader.data or not ws_reader.poi:
        exit(1)

    print("Categories:", ws_reader.category_names)
    print("MC samples:", ws_reader.mc_samples)
    signal_mcs = [x.strip() for x in args.signal_mc.split(',')]
    print("Signal samples:", signal_mcs)

    ws_reader.poi.setVal(args.signalScale)

    if args.fixVar:
        ws_reader.fix_var_str(args.fixVar)
    
    if args.floatVar:
        ws_reader.float_var_str(args.floatVar)

    obs_var = ws_reader.mc.GetObservables().first()
    redefine_range(obs_var, args.nBins, args.xMax, args.xMin)

    # fitting
    snapshot_name = args.save_snapshot_to
    fitted_file_name = args.save_fitted_to
    if args.afterFit:
        if args.conditionalFit:
            ws_reader.fix_var(ws_reader.poi.GetName(), ws_reader.poi.getVal())
        

        ws_reader.fit(snapshot_name, save_to_file=fitted_file_name, do_matrix=args.matrix)

    norm_hist_name = ws_reader.loop_categories(postfix=postfix)

    # background systematic uncertainties
    # obtained by changing all nuisance parameters +/- their error
    # in the nominal pre-fit case, the errors are zero, now corrected to be one.
    up_postfix, down_postfix = 'up', 'down'
    if not add_bkg_sys:
        print("No systematic uncertainties on Background!")
    else:
        # get error of each NP and change them +/- 1 error
        nuisances = ws_reader.mc.GetNuisanceParameters()
        nuisance_snapshot_name = "nuisance_norminal"
        ws_reader.ws.saveSnapshot(nuisance_snapshot_name, nuisances)
        # nuisances.Print("v")
        itr = ROOT.TIter(nuisances.createIterator())
        var = itr()
        while var:
            name = var.GetName()
            error = var.getError()
            norm_val = var.getVal()
            if abs(error) < 1E-10:
                error = 1.
            if verbose:
                print("{}: {} +/- {}".format(name, norm_val, error))
            var = itr()
        # up
        itr = itr.Begin()
        var = itr()
        while var:
            name = var.GetName()
            error = var.getError()
            norm_val = var.getVal()
            if abs(error) < 1E-10:
                error = 1.
            var.setVal(norm_val+error)
            var = itr()
        up_hist_name = ws_reader.loop_categories(postfix=up_postfix)
        ws_reader.ws.loadSnapshot(nuisance_snapshot_name)
        # down
        itr = itr.Begin()
        var = itr()
        while var:
            name = var.GetName()
            error = var.getError()
            norm_val = var.getVal()
            if abs(error) < 1E-10:
                error = 1.
            var.setVal(norm_val-error)
            var = itr()
        down_hist_name = ws_reader.loop_categories(postfix=down_postfix)
        ws_reader.ws.loadSnapshot(nuisance_snapshot_name)

    # Now plotting
    if args.noPlot:
        exit(0)

    f_hist = ROOT.TFile(norm_hist_name)
    if add_bkg_sys:
        f_up = ROOT.TFile(up_hist_name)
        f_down = ROOT.TFile(down_hist_name)

    ps = Ploter(args.plot_type, args.lumi)
    for cat_name in ws_reader.category_names:
        raw_hist_list = []
        raw_tag_list = []
        for mc in ws_reader.mc_samples:
            if mc in signal_mcs:
                continue
            hist_name = '{}-{}-{}__{}'.format(mc, cat_name, postfix, obs_var.GetName())
            hist = f_hist.Get(hist_name)
            hist.SetDirectory(0)
            if add_bkg_sys:
                # access up and down histograms and calculate the variations
                hist_name = '{}-{}-{}__{}'.format(mc, cat_name, up_postfix, obs_var.GetName())
                hist_up = f_up.Get(hist_name)
                hist_name = '{}-{}-{}__{}'.format(mc, cat_name, down_postfix, obs_var.GetName())
                hist_down = f_down.Get(hist_name)
                for ibin in range(hist.GetNbinsX()):
                    norm_val = hist.GetBinContent(ibin+1)
                    up_val = hist_up.GetBinContent(ibin+1)
                    down_val = hist_down.GetBinContent(ibin+1)
                    # symmetric error
                    error = abs(up_val - down_val)*0.5
                    hist.SetBinError(ibin, error)
            else: ## add every small error
                for ibin in range(hist.GetNbinsX()):
                    hist.SetBinError(ibin+1, 1E-6)

            raw_hist_list.append(hist)
            raw_tag_list.append(mc)

        # sort them by number of yields
        sorted_idx = sorted(range(len(raw_hist_list)), key=lambda x: raw_hist_list[x].Integral(), reverse=True)
        hist_list = [raw_hist_list[idx] for idx in sorted_idx]
        tag_list = [raw_tag_list[idx] for idx in sorted_idx]

        hist_data = f_hist.Get("data-{}-{}".format(cat_name, postfix))
        hist_splusb = f_hist.Get("splusb-{}-{}__{}".format(cat_name, postfix, obs_var.GetName()))
        hist_sonlypdf = f_hist.Get("Signal-{}-{}__{}".format(cat_name, postfix, obs_var.GetName()))
        hist_sonly = f_hist.Get("signalOnly-{}-{}".format(cat_name, postfix))

        ps.color(hist_list)
        sum_bkg, hs = ps.stack(hist_list)
        sum_bkg.SetLineColor(1)

        ps.prepare_2pad_canvas("canvas", 600, 600)
        ps.pad2.cd()
 
        new_data_copy = hist_data.Clone("data_copy")
        ps.add_ratio_panel([new_data_copy, sum_bkg], "Data/MC", 0.50, 2.0)

        ps.pad1.cd()
        ps.get_offset(hist_splusb)
        ps.set_y_range([hist_data, hist_splusb], args.logY)
        hist_data.SetXTitle(obs_var.GetName())
        hist_data.SetYTitle("Events")

        if hist_data:
            legend = ps.get_legend(len(hist_list) + 3)
            legend.AddEntry(hist_data, "Data {:.0f}".format(hist_data.Integral()), "LP")
            hist_data.SetMarkerStyle(20)
            hist_data.SetMarkerSize(1)
            hist_data.Draw("EP")
            hs.Draw("HIST same")
            # print("total bins: ", sum_bkg.GetNbinsX())
            # for ibin in range(sum_bkg.GetNbinsX()):
            #     sum_bkg.SetBinError(ibin+1, sum_bkg.GetBinContent(ibin+1)*0.1)

            # show error band for the total background curve
            sum_bkg.SetFillStyle(3244)
            sum_bkg.SetFillColor(2)
            sum_bkg.SetLineColor(2)
            sum_bkg.SetMarkerSize(0.01)
            sum_bkg.Draw("EP same")

            hist_data.Draw("AXISsame")
            hist_data.Draw("EPsame")
            if hist_sonlypdf:
                hist_sonlypdf.Draw("HIST same")
        else:
            legend = ps.get_legend(len(hist_list) + 2)
            hist_splusb.Draw("HIST")
            hs.Draw("E2")
            if hist_sonlypdf:
                hist_sonlypdf.Draw("HIST same")

        #legend.AddEntry(hist_sonly, "S({:.1f}) {:.1f}" .format(self.poi.getVal(), hist_sonly.Integral()), "L")
        if hist_sonlypdf:
            legend.AddEntry(hist_sonlypdf, "S({:.1f}) {}" .format(ws_reader.poi.getVal(), print_hist(hist_sonly, add_bkg_sys)), "L")
        legend.AddEntry(hist_splusb, "S({:.1f})+B {}" .format(ws_reader.poi.getVal(), print_hist(hist_splusb, add_bkg_sys)), "L")
        legend.AddEntry(sum_bkg, "Total Bkg {}".format(print_hist(sum_bkg, add_bkg_sys)), "F")

        for hist, tag in zip(hist_list, tag_list):
            legend.AddEntry(hist, tag+" {}".format(print_hist(hist, add_bkg_sys)), "F")

        legend.Draw("same")
        ps.add_atlas()
        ps.add_lumi()

        ps.can.SaveAs(os.path.join(ws_reader.out_dir, "{}.pdf".format(cat_name)))
        ps.can.SaveAs(os.path.join(ws_reader.out_dir, "{}.eps".format(cat_name)))   

    f_hist.Close()
    if add_bkg_sys:
        f_up.Close()
        f_down.Close()